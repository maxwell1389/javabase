# javabase
Java base utils

Spring
1、spring核心点主要是IOC和AOP，核心技术分别是反射与代理。 
2、bean的声明周期可以分为：
	根据配置生成bean对象
	-> 为bean传入参数
	-> 实现了aware接口可以拿到IOC容器
	-> 实现beanpostProcessor接口可以在bean完成创建的前后去做一些操作
	-> 最后还可以配置init-method会调用对应的函数
	-> 如果配置了destory则会在bean被回收的时候调用对应函数。
3、关于bean的循环依赖问题，单例作用域的bean，通过构造器注入会时循环依赖会报错，因为创建实例对象时无法完成。而通过set/get注入不会报错，因为先创建了实例，spring会缓存一下创建好的bean去注入到对应依赖的bean中。

SpringBoot
1、springboot主要是对各个常用框架的整合，然后自动装配，而简化spring繁杂的xml配置。 
2、springboot还内嵌了一个web服务器，一定程度上简化了部署。


AOP
总结 aop:面向切面,通过动态代理的方式来生成其代理对象在方法执行前后加入自己的逻辑 
- 代理方式:jdk动态代理(接口) cglib动态代理(基于类) 
- 相关名词: 1. JoinPoint连接点:拦截的接口的方法 2. Pointcut切入点:对哪些连接点进行拦截 3. Advice通知:比如前置通知 后置通知 环绕通知 4. aspect切面:切入点和通知组成 
- 切入点 execution表达式 1. execution 权限修饰符 返回值类型 包名.类名.方法名(参数) 
- 通知类型 1. 前置通知:方法执行之前 2. 后置通知:在方法正常执行完毕后(提交事务) 3. 最终通知:在方法正常执行完毕或者出现异常 4. 异常通知:执行过程中出现异常(事物回滚) 5. 环绕通知:方法执行前后,目标方法默认不执行需自己调用方法

IOC
1. toma在启动时会触发容器初始化事件 
2. spring的contextLoaderListener监听到这个事件后会执行contextinitialized方法,在该方法中会初始化spring的根容器即ioc容器,初始化完成之后,会将这个容器放入到servletContext中,以便获取 
3. tomcat在启动过程中还会去扫描加载servlet,比如springmvc的dispatchServlet(前端控制器),用来处理每一个servlet 
4. servlet一般采用延时加载,当一个请求过来的时候发现dispatchservlet还未初始化,则会调用其init方法,初始化时候会建立自己的容器spring mvc容器,同时spring mvc容器通过servletcontext上下文来获取到spring ioc容器将ioc容器设置为其父容器; 
5. 注意事项:spring mvc中容器可以访问spring ioc容器中的bean反之不能即在controller中可以注入service bean对象,在service中不能注入controller容器

SpringMVC
1、服务启动时，将Dispatcher
servlet注入到tomcat中。 
2、tomcat工作线程接收http请求后，将请求转发给Dispatcherservlet。 
3、Dispatcherservlet会查找有@Controller注解标记的类，然后根据uri找到对应目标Controller。 
4、然后在controller中再次找到对应的方法，最后进行一系列的调用。 
5、处理完毕后，分为两种方式返回。
	一是前端页面放在后端工程时，可以返回对应的页面模板名字，然后springmcv使用模板技术进行渲染后返回。
	二是前后端分离以后，直接返回前端所需JSON串即可。

总结： 事务特性：ACID 
原子性：事务要么成功要么失败，没有第三种状态。 
一致性：事务前后数据要一致，也就是事务成功以后对数据的更改要持久化(redo)，事务失败以后要对数据进行回滚(undo)。
隔离性：多个事务之间互不影响(隔离级别)。 
持久性：对数据的更改是持久性的，那么是数据库宕机了，也可以恢复过来(redo)。 
脏读：A事务中读到了B事务还未提交的数据。 
不可重复读：A事务中进行前后两次查询，第二次查询查到了B事务中已提交的更新数据，前后两次查询结果不一致。 
幻读：A事务中进行前后两次查询，第二次查询查到了B事务中已提交的插入数据，查到了原先不存在的数据，像幻觉一样。 
丢失修改：A事务的更新被B事务的更新给替代掉，导致A事务的更改从未发生。 
隔离级别： 读未提交：读到了未提交事务的数据。 
读已提交：读到了已提交事务的数据。 
可重复读：一个事务内的查询结果都是一致的。（mysql默认的隔离级别） 
串行化：事务一个个的来，相当于进了队列。 
mysql-innodb可重复读的实现： innodb给每张表都加了两个隐藏列，创建事务id，删除事务id。要求查询时： 创建事务id <= 当前事务id < 删除事务id。
A事务查询，B事务删除：在A事务内，哪怕B事务删了对应的数据，A事务也能查到符合条件的数据。 
A事务查询，B事务更新：在A事务内，B事务的更新会重新创建一行作为副本，A事务也能查到符合条件的数据。
mysql-innodb还可以解决掉幻读的问题，主要是通过next_key lock这个范围锁实现的，所以mysql-innodb在可重复读的隔离级别下，实现了串行化的隔离要求。
MVCC：多版本并发控制，主要是基于副本机制实现。

总结： 1、索引原理B/B+树，及其区别： B-Tree/B+Tree：一长串定义可以不去背，需要能画得出具体的示意图即可，可以将它们看做是一颗优化过的平衡查找树。
由于查找树的查找效率极高所以选取它们作为索引结构非常合适，但是为了保证树的高度一定而可以存储大量的数据，因此需要选取高阶的查找树。 
二者的区别： B-Tree在非叶子节点中也会存放数据，因此它适合有高频查询的场景，也就是有一个KEY被频繁的查询，走B-Tree的话，可以很快速的查到。但是B-Tree有一个致命的缺点就是没办法高效的进行范围查询，因此慢慢的被B+Tree取代。 
B+Tree的数据只存放在叶子结点，并且每个叶子结点都由头尾指针相连，形成了一个循环的双链表，因此B+Tree的范围查询十分高效。 
2、myisam/innodb 索引结构区别 myisam：该存储引擎将索引文件和数据文件分开，索引文件中保存着数据文件所在的物理地址。 
innodb：该存储引擎索引文件和数据文件都在一起，在索引文件的叶子节点中保存着完整的行数据。而innodb将索引文件分成了两大类，分别是聚集索引和非聚集索引。 
3、聚集索引和非聚集索引 聚集索引：innodb下的每张表必须要指定一个索引，而聚集索引就是基于主键去建立的。聚集索引的结构类似于{"id":"1","pointer":"0007"}其中pointer指向对应的叶子结点。 
非聚集索引：又叫做辅助索引，相当于是对聚集索引的辅助，我们建立的索引都是这类索引，结构类似于{"name":"zhangsan","id":"1"}其中保存着聚集索引中的id。 
以上结构仅仅用于帮助理解和记忆，具体的实现结构是偏移量之类的。 
4、主键的使用细节 主键的使用细节主要是根据B+Tree的特性来，如果使用随机的key来作为主键，可能会导致B+Tree频繁的分裂与合并，开销很大，还有很多碎片，
因此一般建议主键是自增的，这样插入的时候达到了一定的限制后，分裂产生的新的叶子结点就是新插入的那一行数据，因此是规整的。 
5、索引的使用细节，最左前缀匹配原则。 例如有联合索引(a,b,c)那么在这个索引构造的时候，是基于a，然后b，c两列有序的，因此如果不从左到右去匹配，那么索引是无效的。 其余的like/范围查/存在函数等等需要记忆。
6、索引的优劣分析与选择性 优：提升查找效率。 劣：增加磁盘开销，增加（增/删）开销。 选择性：尽可能的选择唯一的列去创建索引。索引创建的数量也应该控制的合理的范围内。 
7、mysql使用建议。 mysql应该被用做于一个及时的存储系统，用来简单的增删改查，以及利用其强大的事务支持。而不应该用作于计算系统，比如做一些join/子查询/函数操作。

总结：三次握手、四次挥手、以及其他TCP协议的控制套件都是为了保证可靠传输。 
1、三次握手：保证client-server都可以进行可靠收发，第三次是为了确认服务端的可靠收发。
还有一种说法就是如果两次就建立连接的话，会因为网络的原因，有些第一次握手的请求滞后了，导致服务端额外的开销，因此出现这种请求，就需要第三次握手去复位连接，释放掉服务端资源。 
2、四次挥手，主要是第二次挥手后服务端依旧可以发送数据，然后client在发出第四次挥手后需要等待2MSL的时间才会进入closed状态。
具体原因也是出于可靠传输，一是为了防止第四次挥手的消息超时，2MSL的时间可以处理超时重发。 
二是为了防止该client在服务端确认关闭前再次连接上该server，保证该连接被正确关闭。挥手过程耗时相对较长，所以说频繁的创建和关闭TCP连接的开销比较大。

总结： http：主要是分为head+body。 
http1.0：每次请求都需要单独建立连接，在获取响应后关闭连接。效率低，不利于复杂网页的加载。 
http1.1：支持TCP长连接，在请求头里面加了一行keep-alive。从而提高效率。
http2.0：有一些新特性，例如多路复用，首部压缩，服务器推送等等。主要是为了进一步提高性能。

总结： https
1、发送自身支持的加密规则，然后网站返回对应的证书回来。 
2、浏览器校验证书后出现一把小锁，然后生成随机数，计算消息hash值，再用该随机数对消息进行加密，最后将随机数进行公钥加密，发送给网站。网站收到消息后，先对整体随机数进行私钥解密，再通过随机数解密消息，对比其hash值，确认未被篡改。 
3、网站再用随机数发送确认，之后浏览器确认以后，那么以后就用随机数进行加密后进行通信。 
4、这个随机数是不能被第三方获取的，因为一开始是浏览器自己生成的，然后发送出去的时候已经用公钥加密了，没有私钥就解不出来。因此，这个随机密码就只会有浏览器和目标网站能拿到。
对称加密：
密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。 
非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

总结： http的长短连接，本质上是TCP的socket连接在一次交互完成后是否进行关闭。

总结：socket是网络套接字，可以通过socket进行TCP层应用的开发。

总结： 网络数据的读取分为两个阶段，
第一个阶段是从网卡读到内核，
第二个阶段是从内核缓存读到用户空间。 
网络模型： 1、同步阻塞IO：在最开始发送一个读取请求的系统调用，OS完成以上两个操作以后响应对应的数据，在这段时间该线程啥都不能做。 
2、同步非阻塞IO：针对于同步阻塞，它在第一个阶段的时间内，采用轮询的方式确认OS内核数据是否准备好，准备好了之后再进行系统读取调用。 
3、多路复用：就是将轮询变成了一个select。对应linux中的是select/poll/epoll。 
4、信号量驱动：上面的select变成了一个信号量。 
5、异步IO：以上两个阶段全部由OS去做，完成后主动回调应用接口。控制反转。 
优劣分析： BIO：基于这种模型下的网络通信，一个请求就需要一个线程，因此不能承受大量客户端。 
优化后的BIO：也是同样的网络模型，不过用线程池来作为了一个缓冲，但是问题依旧是每个请求都需要一个线程去处理，而且资源受限。一旦某些请求卡死，则线程池中线程无法释放会出现问题。 
NIO：NIO其实有两个概念，一个是上面的多路复用模型称之为 no-block IO，还有一个是java里面的New IO库，一般都讲后面那个基于前面那个模型去实现的。
对应的主要组件有selecter/buffer/channel。优点是可以通过多路复用模型管理大量的连接，缺点在于编程的复杂度以及java库本身的bug，所以才有了netty这个框架对New IO库进一步的封装优化。

总结： 32位虚拟机下，处理64位的double/long时的简单赋值操作不是原子的，因为分为高低32位去处理了。
总结： 在32位虚拟机下，用volatile可以保证long/double下的简单赋值操作的原子性。这个是及其特殊的场景，可以忽略。
总结： 涉及到读取-计算-赋值的复杂操作，volatile是无法保证原子操作的，这个关键字的应用场景也不是用来保证原子性的。
总结： 硬件方面：处理器，寄存器，写缓冲器，高速缓存。 写的过程：处理器在计算完某个变量以后，可能将计算后的值写到以上各个硬件中去，如果该变量加了volatile，就会走MESI缓存一致性协议，将该变量更改的消息发送到总线bus中，
接着再把最新的计算值flush到高速缓存或主存中（硬件实现差异），
那么在其他处理器在需要用到该变量的时候，就会嗅探到该变量的更改，就会到更改了该变量的高速缓存或者主存中去加载最新的变量值，从而保证用来计算的值是最新的，这个操作叫做refresh。

总结： 1、锁消除：JIT编译器通过逃逸分析等技术发现有些被加锁的代码不会出现线程安全问题，那么动态编译的时候就会消除掉这个加锁的操作。（一般是有些框架里面自己加的synchronized而我们作为程序员并不知道，主要是优化这个） 
2、锁粗化：多个同步块合并在一起去执行。 
3、偏向锁：偏向于第一个加锁的线程，下一次这个线程再来加锁就不用加锁了，提升性能。但是仅仅适用于非常低的并发场景，因为一旦有第二个线程去尝试加锁，原本偏向的那个线程会被挂起来释放锁，偏向锁也就失效了，升级为轻量级锁。 
4、轻量级锁：主要是基于对象头里面的mark word进行cas，防止每一次加锁都用到os互斥量的重量级锁。这个也仅仅适用于只有少量并发的情况，因为一旦第二个线程加锁失败，进入自旋，仍然失败，就会升级到重量级锁。 
5、自旋锁：为了尽量少使用os的互斥量所做的最后努力（如果重量级锁竞争失败了，会进入自适应自旋），如果自旋也失败了，就会被挂起导致上下文切换。 
6、重量级锁：就是直接使用OS互斥量来进行加锁操作的一种锁，涉及到内核态和用户态的相互转换。


